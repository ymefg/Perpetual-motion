# 名字叫 永动机

高三学生，临近高考，挤时间终于让我给上传到github去了……

## 简介

该程序是一个超级压缩软件，理论上讲可以把几乎无穷大的文件压缩成很小很小的文件。

## 原理

很多压缩程序都是压缩掉了文件里面重复的数据。这样的压缩是有限的，压缩一次之后就很难再进行压缩。

该程序生成一个与被压缩文件一样大小的伪随机文件，然后二者进行异或，得到一个新的文件，再进行普通的压缩。

伪随机文件的内容可以是π、也可以是√2、√3等无理数。

### 程序的工作流程

（并不是很准确）

1. 让用户输入各种参数

2. 确定好伪随机文件的截取范围以及异或次数

3. 进行异或并压缩

4. 截取伪随机文件不同的内容，或者修改异或次数

5. 进行异或并压缩

6. 重复多次第四个第五个步骤…

7. 根据压缩文件的大小，确定能把文件压缩到最小的配置，再用这些参数进行最后的压缩

### 举个简单的例子

详细的栗子在wiki那里。

假设有一个文件a，它的内容是：

`01100111 10100011`

然后生成了一个伪随机文件b，内容：

`10110011 00110101`

二者进行异或，得到新文件c：

`11010100 10010110`

很明显，文件a和文件c的内容都毫无规律可言，压缩之后的文件c和压缩之后的文件a大小差别不大。

于是软件调整配置，生成了伪随机文件d：

`10011001 01001100`

和文件a异或，得到文件e：

`11111110 11101111`

这么多个1！压缩文件e当然可以获得更高的压缩效率！

于是软件压缩文件e并记录下配置信息，等到需要解压的时候，解压文件，再根据配置信息生成伪随机文件d，再和文件e进行异或，就能还原文件a了。

### 概率问题

这的确是一个概率问题。当然，真实的情况不可能像上面那样只重复第二次就可以获得一个压缩率很高的文件。

压缩一个大文件通常都需要循环生成很多个不同的伪随机文件（在无理数的某一个位置截取出来），然后再和文件异或（通常异或次数也可以是不同的）。再进行压缩，统计出每个压缩文件的大小。一直循环尝试不同的配置那么多次，总会有一次是能生成一个刚刚合适的伪随机文件，然后刚刚好和原文件压缩生成一个压缩率很高的文件。

程序在压缩文件后会把配置文件保存下来，记录文件通常包括2个数据：

* 无理数截取的位置

* 异或次数

如果`压缩前文件大小-压缩后文件大小≥压缩后的配置文件大小`的话，就是一次有效的压缩。

如果无限循环压缩，就可以把很大的文件压缩成很小的文件了。

不过，讲道理，怎么可能可以这样压缩？你们快来证明它可不可行吧。

## 这个项目的源码

不要过多的关注源码里面的内容，它并不能被编译成为一个完整的压缩程序。里面有很多错误。自己新建一份源码也好过修改这份源码。

目前的程序源码存在以下问题：

* 无论如何调节filewz函数的参数，生成的异或过后的文件都是一样的。

## 其它

* 如果得出了能否实现的结论，请把这个好消息发给我：yanmingefg@gmail.com
