# 永动机项目

很多人都在github上造轮子，所以github上就有了千千万万个轮子。轮子有什么好造的？还不如弄个永动机出来！

## 简介

如果永动机被发明出来了，那么仅靠它便可以为世界提供无穷无尽的能量；

如果这个项目被实现了，那么全世界的内容仅靠一个π来表示就足够了。

该软件是一个超级压缩软件，理论上讲可以把几乎无穷大的文件压缩成很小很小的文件。永动机已经被能量守恒定律一票否定，但目前还没有任何一位数学家证明这个软件是无法实现的，也没有任何数学家证明可以实现这个软件。

我认为该项目应该是无法实现的，我之所以把它放出来是因为想要找个理论证明它不可行。

要验证这个永动机能不能被研发出来，必须要解决很多个概率问题，然而高中数学并不能很方便地解决这个问题。

## 原理

很多压缩程序都是压缩掉了文件里面重复的数据。这样的压缩是有限的，压缩一次之后就很难再进行压缩。

该程序生成一个与被压缩文件一样大小的伪随机文件，然后二者进行异或，得到一个新的文件，再进行普通的压缩。

伪随机文件的内容可以是π、也可以是√2、√3等无理数。

### 程序的工作流程

1. 让用户输入各种参数

2. 确定好伪随机文件的截取范围以及异或次数

3. 进行异或并压缩

4. 截取伪随机文件不同的内容，或者修改异或次数

5. 进行异或并压缩

6. 重复多次第四个第五个步骤…

7. 根据压缩文件的大小，确定能把文件压缩到最小的配置，再用这些参数进行最后的压缩

### 举个例子

假设有一个文件a，它的内容是：

`01100111 10100011`

然后生成了一个伪随机文件b，内容：

`10110011 00110101`

二者进行异或，得到新文件c：

`11010100 10010110`

很明显，文件a和文件c的内容都毫无规律可言，压缩之后的文件c和压缩之后的文件a大小差别不大。

于是软件调整配置，生成了伪随机文件d：

`10011001 01001100`

和文件a异或，得到文件e：

`11111110 11101111`

这么多个1！压缩文件e当然可以获得更高的压缩效率！

于是软件压缩文件e并记录下配置信息，等到需要解压的时候，解压文件，再根据配置信息生成伪随机文件d，再和文件e进行异或，就能还原文件a了。

### 概率问题

这的确是一个概率问题。当然，真实的情况不可能像上面那样只重复第二次就可以获得一个压缩率很高的文件。

压缩一个大文件通常都需要循环生成很多个不同的伪随机文件（在无理数的某一个位置截取出来），然后再和文件异或（通常异或次数也可以是不同的）。再进行压缩，统计出每个压缩文件的大小。一直循环尝试不同的配置那么多次，总会有一次是能生成一个刚刚合适的伪随机文件，然后刚刚好和原文件压缩生成一个压缩率很高的文件。

程序在压缩文件后会把配置文件保存下来，记录文件通常包括2个数据：

* 无理数截取的位置

* 异或次数

如果`压缩前文件大小-压缩后文件大小≥压缩后的配置文件大小`的话，就是一次有效的压缩。

如果无限循环压缩，就可以把很大的文件压缩成很小的文件了。

但是，怎么可能可以用一个小小的数据来表示比它大很多很多倍的文件呢！这肯定违背了什么原则啊！但可惜的是我没有找到这个原则，并且再百度上搜索不到任何关于异或文件再压缩的程序。所以只能假装它是可以实现的，然后再引起人们的关注，让会数学的人来解决这关于异或文件的概率问题。

## 内容

**未写完……**

由于这个程序是较早创建的，且变量命名和函数命名都不规范，甚至我都不记得一些变量函数当初是怎么命名的了……所以，可能会有点难看。

### 函数

#### filewz

##### 原型

`long filewz (char afname[], char bfname[], int mixtime, int mmover, int delmode, char zipname[], int mixcount);`

##### 作用

异或并压缩文件，返回文件长度。

##### 参数

`char afname[]`临时文件a的地址。

`char bfname[]`临时文件b的地址。

`int mixtime`异或次数。

`int mmover`临时文件截取的位置。

`int delmode`删除模式，0仅删除所有该函数生成的临时文件，1删除所有该函数生成的文件，其它则删除临时文件b和压缩后文件。

`char zipname[]`压缩文件生成的地址。

`int mixcount`当前的异或次数。

#### doublec

##### 原型

`int doublec (int minmix, int maxmix, long mover, int mctime);`

##### 作用

不停地更换配置参数循环filewz，统计压缩后文件的大小，最后根据最佳配置压缩文件。返回0则表示失败，1表示成功。

##### 参数

`int minmix`最小异或次数。

`int maxmix`最大异或次数。

`long mover`伪随机文件可截取的位置范围。

`int mctime`当前已经完整地压缩过的次数。

#### filecopy

##### 原型

`int filecopy (char ofname[], char nfname[]);`

##### 作用

复制文件，返回0失败，1成功。

##### 参数

`char ofname[]`旧文件的地址。

`char nfname[]`新文件的地址。

#### filezip

##### 原型

`long filezip (char filename[], char zipname[], int zipmode);`

##### 作用

调用zip命令压缩文件。返回zip文件的大小。

##### 参数

## 故事

### 灵感

因为篇幅原因无法对关于本程序以外的话题进行讨论，如需了解请点击https://ymefg.win

### 这个程序曾经出现过的版本

还有很多个版本，因时间问题暂时只能写出这些，我会慢慢添加上去的。

#### 用伪随机文件的某一位置表示被压缩文件（不可行）

本程序的第一个版本我是这样想的：如果生成了一个随机文件，那么既然是随机文件，文件内容必定会有和原文件全部内容完全一样的地方，用整数变量数组把那个位置表示出来，再压缩这个数组。

这真是一个糟糕的方法，原文件那么大要找到重合的地方要计算很久，再加上如果找到了那个位置，如果用变量表示出那个位置的话，我相信变量压缩后的大小和原文件压缩后的大小相差无几。（这又是个概率问题，我并没有计算过，“我相信”完全是主观意识）

#### 用伪随机文件的每一小段选择性地和原文件按位与（可行性未知）

该程序的原理是把伪随机文件内容的“1”嵌入到原文件当中再进行压缩。

如果原文件的“1”和伪随机文件的“1”重复了，那么它所在的字节不合并。

假设有一个文件a，它的内容是：

`01100111 10100011`

然后生成了一个伪随机文件b，内容：

`10110011 01011000`

然后程序把文件a和文件b的内容进行对比，发现两个文件第一个字节里的“1”重复了，不合并，第二个字节里的“1”没有重复，合并。

得到文件c：

`01100111 11111011`

同时程序生成一个文件d，它记录了每个字节是否合并的数据。如果不合并，则记录0，合并记录1。

文件d：

`01…`

把文件d和文件c进行压缩就完成了一次压缩。

### 为什么会有这个项目

这段话好长并且和这个项目相关性不大，其实是不应该出现在README.md里的。

以下是我个人的胡乱想象，程序能不能做得出来还是个未知数，而我却一边做一边想了。

我刚开始全力以赴做这个项目时是想着闭源的，当时离高考还有一百多天。闭源是有原因的：

* 不想自己的心血随意被他人使用。

* 万一真的研发出来了，那么一些很大的盗版资源就可以被压缩成很小的文件，这样一来盗版传播就更加方便了，可能比bt种子还厉害。

* 赚钱。

* 万一真的研发出来了，万一被某所学院因此而录取了呢。

坦白说，我考试的成绩并不理想，竭尽所能只能在本科线上下徘徊，最多只能考个3A院校。我就觉得，这个程序真的是我唯一的希望啊！研究出来了就是一个能改变全世界的发明！那些大学是有可能破格录取我的啊！即使没有被破格录取，研究出来申请个专利，下半生的生活就无忧了！

不过在前进的道路上，障碍还是有很多的。现在我唯一一台可以编程的工具就是我手上的小米2s，连个电脑都没有。相对于电脑的工作效率，手机的效率只能望其项背：打字慢、屏幕小，一些在电脑上面都很复杂的操作换到手机上面就更难操作了。因为是压缩文件的程序，而自学C语言的我根本不会任何压缩文件的方法，百度谷歌也找不到C语言的压缩程序源码，这就需要投机取巧了：Linux可以使用zip命令压缩文件，而C语言也可以调用命令行。但是这样做又引出了一个新的问题：安卓系统根本就没有“zip”这个程序，即使是安装了busybox之后也只提供一个“unzip”命令。不过恰好我这个寒假发现了LinuxDeploy这个软件，我手机上面刚好安装了个Ubuntu。虽然测试程序的时候麻烦了，需要复制粘贴再ssh连接容器用gcc编译再在Linux上运行。但这些关键问题都被我解决了，再麻烦也无所谓啦。

后来一个同学借来了几本杂志分给大家看，我在16年的《微型计算机》上看到了一篇文章，内容摘要大概是这样的：清华大学对英雄联盟世界冠军可以考虑特招进校学习。我顿时就兴奋了，既然连英雄联盟世界冠军都可以被特招进清华，那么我这个改变世界的程序的发明者也同样可以被特招进去吧？

距离高考还有30天的时候，我考虑到开源了，因为我一个只是自学过编程的人根本没有能力高效率地开发下去，再加上是高三学生，根本没有多少时间进行吃饭睡觉上课之外的活动。于是准备重新搭建博客，并在github上创建这个项目。

离高考还有20天的深夜23:49，我写到了这里，这个时候博客已经搞定了，README.md也写得七七八八了，应该后天考完热身考试后就能上传源码了。

### 关于我

高三学生，成绩不理想，渴望上到好一点的学校来学习编程。看到好多人都在某某大学读书真的好羡慕啊，学校带有“大学”2字读得顺口，也突出了是重点学校，无奈自己对学习语数英物化生不感兴趣，将来只能读某某职业技术学院了。

我和C语言：

* 2014年7月接触C语言，在C语言中文网自学了2个月，期间做了一个井字棋和一个解一元二次方程程序，流程控制只会一直用goto，后来一直不怎么学习。

* 2016年，买了一本《C Primer Plus》学习。刚开始经常看，后来就偶尔看看当参考书了。

* 2017年3月知道自己成绩不好，又突然想到了这个程序，然后我就开始做这个项目了。

* 2017年5月，深知自己实力不够，决定开源。
